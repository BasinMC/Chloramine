/*
 * Copyright 2019 Johannes Donath <johannesd@torchmind.com>
 * and other copyright owners as documented in the project's IP log.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.basinmc.chloramine.manifest.metadata;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import java.net.URI;
import java.util.List;
import java.util.Optional;

/**
 * Represents a set of basic extension metadata which informs the server about potential
 * dependencies, provided services, authors and other support related information.
 *
 * @author <a href="mailto:johannesd@torchmind.com">Johannes Donath</a>
 */
public interface Metadata extends BinarySerializable {

  /**
   * Identifies an extension which is only privately available (e.g. has been developed for a
   * specific server or group of people and is not publicly distributed).
   */
  int FLAG_PRIVATE = 0b0000_0000_0001_0000;

  /**
   * Identifies a commercial extension which is available for a licensing fee or has been
   * commissioned.
   */
  int FLAG_COMMERCIAL = 0b0000_0000_0010_0000;

  /**
   * Identifies a build which has been generated by a CI server and may thus be unstable (e.g.
   * automated non-release build).
   */
  int FLAG_CI_BUILD = 0b0000_0000_1000_0000;

  /**
   * <p>Retrieves the format revision of this metadata object.</p>
   *
   * <p>This value may be used to infer which information is actually available within the metadata
   * object when backwards compatibility is desired.</p>
   *
   * <p>Refer to the <a href="https://wiki.basinmc.org/display/BAS/BEP-1+-+Extension+Container">format
   * documentation</a> for more information.</p>
   *
   * @return a format revision.
   */
  short getFormatVersion();

  /**
   * <p>Retrieves the product for which this extension is intended.</p>
   *
   * <p>Due to the generic nature of the container format, extensions may be packaged for any
   * number of products. Implementations should <strong>always</strong> evaluate whether this value
   * matches their expected product identifier before loading an extension.</p>
   *
   * @return a unique product identifier.
   */
  @NonNull
  String getProductIdentifier();

  /**
   * <p>Identifies the extension's desired environment type.</p>
   *
   * <p>This value identifies the desired loading behavior (e.g. when multiple scripting backends
   * are supported by the server).</p>
   *
   * <p>The list of supported environment types heavily depends on the application in question.</p>
   *
   * @return an environment type.
   */
  @NonNull
  String getEnvironmentType();

  /**
   * <p>Retrieves a set of metadata flags which expose additional build information.</p>
   *
   * <p><strong>Note:</strong> Additional flags may be introduced within future versions without
   * incrementing the format version (given that these flags are purely for documentation
   * purposes).</p>
   *
   * @return a bit mask of flags.
   */
  int getFlags();

  /**
   * <p>Retrieves the product-specific identifier of this extension.</p>
   *
   * <p>Applications may safely expect this value to be equal to the Java package name format.</p>
   *
   * <p>This value is guaranteed to be unique within the ecosystem of a single product and may
   * never conflict with other loaded extensions.</p>
   *
   * @return an extension identifier.
   */
  @NonNull
  String getIdentifier();

  /**
   * <p>Retrieves the extension revision.</p>
   *
   * <p>This value is expected to the <a href="https://semver.org/">Semantic Versioning</a>
   * specification in order to provide support for parsing and version ranges within
   * dependencies.</p>
   *
   * <p>Versions are expected to be unique within the namespace of a single extension (as denoted
   * by its identifier).</p>
   *
   * @return a unique version identifier.
   */
  @NonNull
  String getVersion();

  /**
   * Retrieves a link to the official distribution method (e.g. a website or service where the user
   * may retrieve a newer revision of this extension).
   *
   * @return a distribution URI.
   */
  @NonNull
  Optional<URI> getDistributionUrl();

  /**
   * Retrieves a link to the official documentation page.
   *
   * @return a documentation URI.
   */
  @NonNull
  Optional<URI> getDocumentationUrl();

  /**
   * Retrieves a link to the official issue reporting method (e.g. a website or service where the
   * user may report bugs or suggest new features).
   *
   * @return an issue reporting URI.
   */
  @NonNull
  Optional<URI> getIssueReportingUrl();

  /**
   * <p>Retrieves a list of active authors.</p>
   *
   * <p>A developer is considered an author while they are actively working on the product
   * (typically once permanent pushing privileged are granted).</p>
   *
   * @return a list of authors.
   */
  @NonNull
  List<Author> getAuthors();

  /**
   * <p>Retrieves a list of contributors.</p>
   *
   * <p>A developer is considered a contributor once they have one or more contributions within the
   * project codebase. Contributors are promoted to author status when they regularly work on the
   * project and demoted again when they leave the project for longer periods of time.</p>
   *
   * <p>Note that this differentiation is highly subjective. Some projects may choose to retain the
   * author status of original maintainers even when they pass along a project.</p>
   *
   * @return a list of extension contributors.
   * @see Author
   */
  @NonNull
  List<Author> getContributors();

  /**
   * Retrieves a list of services which are exposed by the extension.
   *
   * @return a list of services.
   * @see Service
   */
  @NonNull
  List<Service> getProvidedServices();

  /**
   * <p>Retrieves a list of extensions on which this extension depends.</p>
   *
   * <p>The elements within this list may either completely prevent extension initialization if the
   * dependency is missing or declare an optional dependency (which grants access to the dependency
   * if present but does not prevent loading).</p>
   *
   * @return a list of extension dependencies.
   * @see Dependency
   */
  @NonNull
  List<Dependency> getExtensionDependencies();

  /**
   * <p>Retrieves a list of services on which this extension depends.</p>
   *
   * <p>The elements within this list may either completely prevent extension initialization if the
   * service is not available for consumption or declare an optional dependency (which grants access
   * to a service when available but does not prevent loading).</p>
   *
   * @return a list of service dependencies.
   * @see Dependency
   */
  @NonNull
  List<Dependency> getServiceDependencies();

  // TODO: Do not throw if field is unknown?
  //       Might be reasonable to provide a flag for the caller to choose whether they wish for a
  //       silent failure or bells and whistles?
  interface Builder {

    /**
     * @return a fully built metadata object.
     * @throws IllegalStateException when a required field has not been passed.
     */
    @NonNull
    Metadata build();

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getProductIdentifier()
     */
    @NonNull
    Builder setProductIdentifier(@NonNull String identifier);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getEnvironmentType()
     */
    @NonNull
    Builder setEnvironmentType(@NonNull String environmentType);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getFlags()
     */
    @NonNull
    Builder setFlags(int flags);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getIdentifier()
     */
    @NonNull
    Builder setIdentifier(@NonNull String identifier);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getVersion()
     */
    @NonNull
    Builder setVersion(@NonNull String version);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getDistributionUrl()
     */
    @NonNull
    Builder setDistributionUrl(@NonNull URI distributionUrl);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getDocumentationUrl()
     */
    @NonNull
    Builder setDocumentationUrl(@NonNull URI documentationUrl);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getIssueReportingUrl()
     */
    @NonNull
    Builder setIssueReportingUrl(@NonNull URI issueReportingUrl);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getAuthors()
     */
    @NonNull
    Builder addAuthor(@NonNull String name, @Nullable String alias);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getContributors()
     */
    @NonNull
    Builder addContributor(@NonNull String name, @Nullable String alias);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getServiceDependencies()
     */
    @NonNull
    Builder addService(@NonNull String identifier, @NonNull String version);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getExtensionDependencies()
     */
    @NonNull
    Builder addExtensionDependency(@NonNull String identifier, @NonNull String versionRange,
        boolean optional);

    /**
     * @throws IllegalArgumentException when the specified value is invalid
     * @throws UnsupportedOperationException when this field is not supported by the format
     * revision
     * @see Metadata#getServiceDependencies()
     */
    @NonNull
    Builder addServiceDependency(@NonNull String identifier, @NonNull String versionRange,
        boolean optional);
  }
}
